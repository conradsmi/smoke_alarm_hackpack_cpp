{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	  "Initialize": {
		"prefix": ["hack_initialize"],
		"body": [
			"#include <bits/stdc++.h>",
			"#define oo (int)1e9",
			"using namespace std;",
			"using ll = long long;",
			"using pll = pair<ll, ll>;",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(NULL);",
			"",
			"    return 0;",
			"}"
		],
		"description": "An initialized C++ program for competitive programming."
	  },

	  "Multiset-While": {
		"prefix": ["hack_w-multiset"],
		"body": [
			"int num_cases;",
			"cin >> num_cases;",
			"while (num_cases--) {",
			"    ",
			"}"
		],
		"description": "For multiset problems where test case index is not needed"
	  },

	  "Multiset-For": {
		"prefix": ["hack_f-multiset"],
		"body": [
			"int num_cases;",
			"cin >> num_cases;",
			"for (int index = 1; index <= num_cases; index++) {",
			"    ",
			"}"
		],
		"description": "For multiset problems where test case index is needed"
	  },

	  "Adjacency List": {
		"prefix": "hack_adjlist",
		"body": [
		  "// adjacency list for graph problems",
		  "struct adj_list {",
		  "    vector<vector<int>> adj;",
		  "    int n;",
		  "",
		  "    adj_list(int n_) {",
		  "        adj = vector<vector<int>>(n_);",
		  "        n = n_;",
		  "    }",
		  "",
		  "    void addEdge(int u, int v) {",
		  "        adj[u].push_back(v);",
		  "    }",
		  "};"
		],
		"description": "Adjacency List"
	  },

	  "Edge Struct": {
		"prefix": "hack_edge",
		"body": [
		  "struct edge {",
		  "    int v1, v2, w;",
		  "    edge(){}",
		  "    edge(int v1_, int v2_, int w_) {",
		  "        v1 = v1_;",
		  "        v2 = v2_;",
		  "        w = w_;",
		  "    }",
		  "};",
		  "",
		  "bool compareEdge(const edge &a, const edge &b) {",
		  "    return a.w < b.w;",
		  "}"
		],
		"description": "Edge Struct"
	  },

	  "Topological Sort": {
		"prefix": "hack_topsort",
		"body": [
		  "// get a topological sort - O(V+E)",
		  "vector<int> topSort(vector<vector<int>> graph) {",
		  "    int n = graph.size();",
		  "",
		  "    // calculate in degrees",
		  "    vector<int> in_degrees(n);",
		  "    for (int i = 0; i < n; i++)",
		  "        for (int j : graph[i])",
		  "            in_degrees[j]++;",
		  "",
		  "    // store answer",
		  "    vector<int> res(n);",
		  "",
		  "    // store all integers ready to be added",
		  "    queue<int> q;",
		  "    for (int i = 0; i < n; i++)",
		  "        if (in_degrees[i] == 0)",
		  "            q.push(i);",
		  "",
		  "    // Fill in each item",
		  "    for (int i = 0; i < n; i++) {",
		  "        // there were no nodes that reached an in_degree of 0 on the last iteration,",
		  "        // so there is no valid topological sort",
		  "        if (q.size() == 0)",
		  "            return vector<int>();",
		  "",
		  "        // this vertex is safe to add in",
		  "        res[i] = q.front();",
		  "        q.pop();",
		  "",
		  "        // Each vertex on an edge from res[i] reduces it indegree by 1",
		  "        // since res[i] is completed",
		  "        for (int j : graph[res[i]]) {",
		  "            in_degrees[j]--;",
		  "            // if x gets down to 0, add it to list of vertices we can schedule",
		  "            if (in_degrees[j] == 0)",
		  "                q.push(j);",
		  "        }",
		  "    }",
		  "",
		  "    return res;",
		  "}"
		],
		"description": "Topological Sort"
	  },

	  "Disjoint Sets": {
		"prefix": "hack_djsets",
		"body": [
		  "struct djset {",
		  "    vector<int> parent;",
		  "    vector<int> height;",
		  "",
		  "    djset(){}",
		  "    djset(int items) {",
		  "        parent = vector<int>(items);",
		  "        height = vector<int>(items);",
		  "",
		  "        for (int i = 0; i < items; i++) {",
		  "            parent[i] = i;",
		  "            height[i] = 0;",
		  "        }",
		  "    }",
		  "",
		  "    int findRep(int v) {",
		  "        if (parent[v] == v)",
		  "            return v;",
		  "        parent[v] = findRep(parent[v]);",
		  "        height[v] = 1;",
		  "        return parent[v];",
		  "    }",
		  "",
		  "    bool unify(int v1, int v2) {",
		  "        int r1 = findRep(v1);",
		  "        int r2 = findRep(v2);",
		  "",
		  "        if (r1 == r2)",
		  "            return false;",
		  "",
		  "        if (height[r2] < height[r1])",
		  "            parent[r2] = r1;",
		  "        else if (height[r1] < height[r2])",
		  "            parent[r1] = r2;",
		  "        else {",
		  "            parent[r2] = r1;",
		  "            height[r1]++;",
		  "        }",
		  "",
		  "        return true;",
		  "    }",
		  "};"
		],
		"description": "Disjoint Sets"
	  },

	  "Kruskal's Algorithm (MST)": {
		"prefix": "hack_kruskal",
		"body": [
		  "int kruskalMST(vector<edge> edges, int n) {",
		  "    sort(edges.begin(), edges.end(), compareEdge);",
		  "    djset ds = djset(n);",
		  "    int numEdges = 0, sum = 0;",
		  "",
		  "    for (int e = 0; e < edges.size(); e++) {",
		  "        if (ds.unify(edges[e].v1, edges[e].v2)) {",
		  "            numEdges++;",
		  "            sum += edges[e].w;",
		  "            if (numEdges == n-1) break;",
		  "        }",
		  "    }",
		  "",
		  "    return numEdges == n-1 ? sum : -1;",
		  "}"
		],
		"description": "Kruskal's Algorithm (MST)"
	  },

	  "Binary Index Tree": {
		"prefix": "hack_binary_index_tree",
		"body": [
		  "vector<ll> bin_it;",
		  "",
		  "void bitInit(vector<ll> cumfreq) {",
		  "    bin_it = vector<ll>(cumfreq.size(), 0);",
		  "    for (int i = 0; i < cumfreq.size(); i++)",
		  "        BIT_add(i, cumfreq[i]);",
		  "}",
		  "",
		  "void bitAdd(int index, ll value) {",
		  "    while (index < bin_it.size()) {",
		  "        bin_it[index] += value;",
		  "        index += ffsll(index);",
		  "    }",
		  "}",
		  "",
		  "ll bitSum(int index) {",
		  "    ll ans = 0;",
		  "    while (index > 0) {",
		  "        ans += bin_it[index];",
		  "        index -= ffsll(index);",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "Binary Index Tree"
	  },

	  "Floyd-Warshall Algorithm (Shortest Distance)": {
		"prefix": "hack_floydwarshall",
		"body": [
		  "// get shortest distance between every vertex in the adjacency matrix - O(|V|^3)",
		  "pair<vector<vector<int>>, vector<vector<int>>> floydWarshall(vector<vector<int>> graph) {",
		  "    int n = graph.size();",
		  "    // create a memo",
		  "    vector<vector<int>> memo(graph);",
		  "    // store path info for path reconstruction",
		  "    vector<vector<int>> path(n, vector<int>(n, -1));",
		  "",
		  "    // k = id of vertex used in intermediate path",
		  "    for (int k = 0; k < n; k++) {",
		  "        // i = \"from\" node",
		  "        for (int i = 0; i < n; i++) {",
		  "            // j = \"to\" node",
		  "            for (int j = 0; j < n; j++) {",
		  "                // update path reconstruction matrix & shortest distance matrix",
		  "                if (memo[i][k] + memo[k][j] < memo[i][j]) {",
		  "                    memo[i][j] = memo[i][k] + memo[k][j];",
		  "                    path[i][j] = path[k][j];",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    // return both",
		  "    return make_pair(memo, path);",
		  "}"
		],
		"description": "Floyd-Warshall Algorithm (Shortest Distance)"
	  }
}