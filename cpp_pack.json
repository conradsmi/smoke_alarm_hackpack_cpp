{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	  // GENERAL

	  "Initialize": {
		"prefix": ["hack_initialize"],
		"body": [
			"#include <bits/stdc++.h>",
			"#define oo (int)1e9",
			"#define all(a) a.begin(), a.end()",
			"using namespace std;",
			"using ll = long long;",
			"using pll = pair<ll, ll>;",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(NULL);",
			"",
			"    return 0;",
			"}"
		],
		"description": "An initialized C++ program for competitive programming."
	  },

	  "Multiset-While": {
		"prefix": ["hack_w-multiset"],
		"body": [
			"int num_cases;",
			"cin >> num_cases;",
			"while (num_cases--) {",
			"    ",
			"}"
		],
		"description": "For multiset problems where test case index is not needed"
	  },

	  "Multiset-For": {
		"prefix": ["hack_f-multiset"],
		"body": [
			"int num_cases;",
			"cin >> num_cases;",
			"for (int index = 1; index <= num_cases; index++) {",
			"    ",
			"}"
		],
		"description": "For multiset problems where test case index is needed"
	  },

	  // GRAPH

	  "Dijkstra's Algorithm (Shortest Distance)": {
		"prefix": "hack_dijkstra",
		"body": [
		  "// assumes no negative edges - O(|V|^2 * log(|V|)^2)",
		  "template <typename T>",
		  "pair<vector<T>, vector<int>> dijkstra(vector<vector<pair<int, T>>> graph, int start) {",
		  "    using PT = pair<int, T>; // Pair Type",
		  "",
		  "    int n = graph.size();",
		  "    vector<bool> visited(n, false);",
		  "    visited[start] = true;",
		  "    vector<T> dist(n);",
		  "    vector<int> path(n);",
		  "",
		  "    // 1st = node ID, 2nd = distance from node to start when inserted",
		  "    priority_queue<PT, vector<PT>, decltype(compareDist)> lowest(compareDist);",
		  "    lowest.emplace(start, 0);",
		  "",
		  "    // visit every edge",
		  "    while (!lowest.empty()) {",
		  "        // source, dist",
		  "        auto [u, d] = lowest.top();",
		  "        lowest.pop();",
		  "",
		  "        if (dist[u] < d)",
		  "            continue;",
		  "",
		  "        for (auto e : graph[u]) {",
		  "            // sink, weight",
		  "            auto [v, w] = e;",
		  "            if (!visited[v] || dist[u] + w < dist[v]) {",
		  "                dist[v] = dist[u] + w;",
		  "                path[v] = u;",
		  "                lowest.emplace(v, dist[v]);",
		  "                visited[v] = true;",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    return {dist, path};",
		  "}",
		  "",
		  "template <typename T>",
		  "auto compareDist = [](const pair<int, T> &a, const pair<int, T> &b) {",
		  "    return a.second > b.second;",
		  "};"
		],
		"description": "Dijkstra's Algorithm (Shortest Distance)"
	  },

	  "Bellman Ford (Shortest Distance)": {
		"prefix": "hack_bellmanford",
		"body": [
		  "// get shortest distance from source vertex to every other vertex in matrix - O(|V|^3)",
		  "// [assumes empty edges of graph are valued as infinity (oo)]",
		  "// [use this instead of dijkstras when graph has negative edge weights]",
		  "// return shortest distance vector and path reconstruction vector",
		  "pair<vector<int>, vector<int>> bellmanFord(vector<vector<int>> graph, int source) {",
		  "    int n = graph.size();",
		  "    // shortest distance",
		  "    vector<int> dist(n, oo);",
		  "    // path reconstruction",
		  "    vector<int> path(n, -1);",
		  "    dist[source] = 0;",
		  "",
		  "    // calculate minimum distances",
		  "    for (int k = 0; k < n; k++) {",
		  "        for (int i = 0; i < n; i++) {",
		  "            for (int j = 0; j < n; j++) {",
		  "                // update path reconstruction vector & shortest distance vector",
		  "                if (dist[i] + graph[i][j] < dist[j]) {",
		  "                    dist[j] = dist[i] + graph[i][j];",
		  "                    path[j] = i;",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    // look for negative cycles",
		  "    for (int i = 0; i < n; i++)",
		  "        for (int j = 0; j < n; j++)",
		  "            // if we do one more iteration and get a shorter path for any vertex,",
		  "            // then there is negative cycle",
		  "            if (dist[i] + graph[i][j] < dist[j])",
		  "                return make_pair(vector<int>(), vector<int>());",
		  "",
		  "    // return both",
		  "    return make_pair(dist, path);",
		  "}"
		],
		"description": "Bellman Ford (Shortest Distance)"
	  },

	  "Floyd-Warshall Algorithm (Shortest Distances)": {
		"prefix": "hack_floydWarshall",
		"body": [
		  "// get shortest distance between every vertex in the adjacency matrix - O(|V|^3)",
		  "template <typename T>",
		  "pair<vector<vector<T>>, vector<vector<T>>> floydWarshall(vector<vector<T>> graph) {",
		  "    using GT = vector<vector<T>> // Graph Type",
		  "    int n = graph.size();",
		  "",
		  "    // create a memo",
		  "    GT memo(graph);",
		  "    // store path info for path reconstruction",
		  "    GT path(n, vector<T>(n, -1));",
		  "",
		  "    // k = # of vertex used in intermediate path",
		  "    for (int k = 0; k < n; k++) {",
		  "        // i = \"from\" node",
		  "        for (int i = 0; i < n; i++) {",
		  "            // j = \"to\" node",
		  "            for (int j = 0; j < n; j++) {",
		  "                // update path reconstruction matrix & shortest distance matrix",
		  "                if (memo[i][k] + memo[k][j] < memo[i][j]) {",
		  "                    memo[i][j] = memo[i][k] + memo[k][j];",
		  "                    path[i][j] = path[k][j];",
		  "                }",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    return {memo, path};",
		  "}"
		],
		"description": "Floyd-Warshall Algorithm (Shortest Distances)"
	  },

	  "Topological Sort": {
		"prefix": "hack_topsort",
		"body": [
		  "// get a topological sort - O(V+E)",
		  "vector<int> topSort(vector<vector<int>> &graph) {",
		  "    int n = graph.size();",
		  "",
		  "    // calculate in degrees",
		  "    vector<int> in_degrees(n);",
		  "    for (int i = 0; i < n; i++)",
		  "        for (int j : graph[i])",
		  "            in_degrees[j]++;",
		  "",
		  "    // store answer",
		  "    vector<int> res(n);",
		  "",
		  "    // store all integers ready to be added",
		  "    queue<int> q;",
		  "    for (int i = 0; i < n; i++)",
		  "        if (in_degrees[i] == 0)",
		  "            q.push(i);",
		  "",
		  "    // Fill in each item",
		  "    for (int i = 0; i < n; i++) {",
		  "        // there were no nodes that reached an in_degree of 0 on the last iteration,",
		  "        // so there is no valid topological sort",
		  "        if (q.size() == 0)",
		  "            return vector<int>();",
		  "",
		  "        // this vertex is safe to add in",
		  "        res[i] = q.front();",
		  "        q.pop();",
		  "",
		  "        // Each vertex on an edge from res[i] reduces it indegree by 1",
		  "        // since res[i] is completed",
		  "        for (int j : graph[res[i]]) {",
		  "            in_degrees[j]--;",
		  "            // if x gets down to 0, add it to list of vertices we can schedule",
		  "            if (in_degrees[j] == 0)",
		  "                q.push(j);",
		  "        }",
		  "    }",
		  "",
		  "    return res;",
		  "}"
		],
		"description": "Topological Sort"
	  },

	  "All Topological Sorts": {
		  "prefix": "allTopSort",
		  "body": [
			"// get all topological sorts",
			"void allTopSortUtil(vector<vector<int>> &graph, vector<vector<int>> &ans, vector<int> &curr, vector<int> &in_degrees, vector<bool> &visited) {",
			"    int n = graph.size();",
			"    bool done = false;",
			"",
			"    for (int i = 0; i < n; i++) {",
			"        // ready to visit",
			"        if (in_degrees[i] == 0 && !visited[i]) {",
			"            // Each vertex on an edge from res[i] reduces it indegree by 1",
			"            // since res[i] is completed",
			"            for (int j : graph[i])",
			"                in_degrees[j]--;",
			"",
			"            // this vertex is safe to add in, use backtracking to find more",
			"            curr.push_back(i);",
			"            visited[i] = true;",
			"            allTopSortUtil(graph, ans, curr, in_degrees, visited);",
			"",
			"            // backtracking done, reset state",
			"            visited[i] = false;",
			"            curr.pop_back();",
			"            for (int j : graph[i])",
			"                in_degrees[j]++;",
			"",
			"            done = true;",
			"        }",
			"    }",
			"",
			"    if (!done)",
			"        ans.push_back(curr);",
			"}",
			"",
			"vector<vector<int>> allTopSort(vector<vector<int>> &graph) {",
			"    int n = graph.size();",
			"    vector<bool> visited(n, false);",
			"",
			"    // calculate in degrees",
			"    vector<int> in_degrees(n);",
			"    for (int i = 0; i < n; i++)",
			"        for (int j : graph[i])",
			"            in_degrees[j]++;",
			"",
			"    vector<vector<int>> res;",
			"    vector<int> curr;",
			"    allTopSortUtil(graph, res, curr, in_degrees, visited);",
			"    return res;",
			"}"
		  ],
		  "description": "All Topological Sorts"
		},

	  "Edge Struct": {
		"prefix": "hack_edge",
		"body": [
		  "template <typename T>",
		  "struct edge {",
		  "    int v1, v2;",
		  "    T w;",
		  "    edge(){}",
		  "    edge(int v1_, int v2_, T w_) {",
		  "        v1 = v1_;",
		  "        v2 = v2_;",
		  "        w = w_;",
		  "    }",
		  "",
		  "    bool operator<(const edge<T> &a, const edge<T> &b) {",
		  "        return a.w < b.w;",
		  "    }",
		  "};"
		],
		"description": "Edge Struct"
	  },

	  "Disjoint Sets Struct": {
		"prefix": "hack_djsets",
		"body": [
		  "struct djset {",
		  "    vector<int> parent;",
		  "    vector<int> height;",
		  "    int n;",
		  "",
		  "    djset(){}",
		  "    djset(int n_) {",
		  "        n = n_;",
		  "        parent = vector<int>(n_);",
		  "        height = vector<int>(n_);",
		  "",
		  "        for (int i = 0; i < n_; i++) {",
		  "            parent[i] = i;",
		  "        }",
		  "    }",
		  "",
		  "    int findRep(int v) {",
		  "        if (parent[v] == v)",
		  "            return v;",
		  "        parent[v] = findRep(parent[v]);",
		  "        height[v] = 1;",
		  "        return parent[v];",
		  "    }",
		  "",
		  "    bool unify(int v1, int v2) {",
		  "        int r1 = findRep(v1);",
		  "        int r2 = findRep(v2);",
		  "",
		  "        if (r1 == r2)",
		  "            return false;",
		  "",
		  "        int h1 = height[r1];",
		  "        int h2 = height[r2];",
		  "",
		  "        if (h2 < h1)",
		  "            parent[r2] = r1;",
		  "        else if (h1 < h2)",
		  "            parent[r1] = r2;",
		  "        else {",
		  "            parent[r2] = r1;",
		  "            height[r1]++;",
		  "        }",
		  "",
		  "        return true;",
		  "    }",
		  "};"
		],
		"description": "Disjoint Sets Struct"
	  },

	  "Kruskal's Algorithm (MST)": {
		"prefix": "hack_kruskal",
		"body": [
		  "template <typename T>",
		  "int kruskalMST(vector<edge<T>> edges, int n) {",
		  "    sort(all(edges));",
		  "    djset ds = djset(n);",
		  "    int sum = 0;",
		  "",
		  "    for (int e = 0; e < n && ds.n > 1; e++)",
		  "        if (ds.unify(edges[e].v1, edges[e].v2))",
		  "            sum += edges[e].w;",
		  "",
		  "    return ds.n == 1 ? sum : -1;",
		  "}"
		],
		"description": "Kruskal's Algorithm (MST)"
	  },

	  "Binary Index Tree": {
		"prefix": "hack_binary_index_tree",
		"body": [
		  "vector<ll> bin_it;",
		  "",
		  "void bitInit(vector<ll> cumfreq) {",
		  "    bin_it = vector<ll>(cumfreq.size(), 0);",
		  "    for (int i = 0; i < cumfreq.size(); i++)",
		  "        BIT_add(i, cumfreq[i]);",
		  "}",
		  "",
		  "void bitAdd(int index, ll value) {",
		  "    while (index < bin_it.size()) {",
		  "        bin_it[index] += value;",
		  "        index += ffsll(index);",
		  "    }",
		  "}",
		  "",
		  "ll bitSum(int index) {",
		  "    ll ans = 0;",
		  "    while (index > 0) {",
		  "        ans += bin_it[index];",
		  "        index -= ffsll(index);",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "Binary Index Tree"
	  },

	  "Fastpow": {
		"prefix": "hack_fastpow",
		"body": [
		  "template <typename T>",
		  "T power(int base, int exp) {",
		  "    if (exp == 0)",
		  "        return 1;",
		  "",
		  "    T half = power<T>(base, exp / 2);",
		  "    return (exp % 2 == 0) ? (half * half) : (base * half * half);",
		  "}"
		],
		"description": "Fastpow"
	  }
}
